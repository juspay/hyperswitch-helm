name: CI-PR

on:
  pull_request:
    paths:
      - "charts/**"
  workflow_dispatch: # Allow manual triggering

# Cancel previous runs on new pushes to the same PR
concurrency:
  group: ${{ github.workflow }}-${{ github.event.pull_request.number || github.ref }}
  cancel-in-progress: true

permissions:
  contents: read
  pull-requests: read

env:
  CT_CONFIGFILE: ct.yaml
  CT_CHECK_VERSION_INCREMENT: true
  HELM_VERSION: v3.14.0 # Updated to latest stable version
  KUBECTL_VERSION: v1.30.3 # Updated to latest stable version
  KIND_VERSION: v0.24.0 # Pinned kind version
  PYTHON_VERSION: "3.12"

# Define default shell for consistency
defaults:
  run:
    shell: bash

jobs:
  detect-changes:
    name: Detect Changed Charts
    runs-on: ubuntu-latest
    outputs:
      changed: ${{ steps.list-changed.outputs.changed }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up chart-testing
        uses: helm/chart-testing-action@v2.1.0

      - name: Detect changed charts
        id: list-changed
        run: |
          changed=$(ct list-changed --config "${CT_CONFIGFILE}")
          echo "changed=$([[ -n \"$changed\" ]] && echo true || echo false)" >> "$GITHUB_OUTPUT"

  check-helm-docs:
    name: Check Helm Docs
    needs: detect-changes
    runs-on: ubuntu-latest
    if: needs.detect-changes.outputs.changed == 'true'
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
        with:
          persist-credentials: false

      - name: Check Helm-Docs updated
        run: |
          docker run --rm \
          -v $(pwd):/helm-docs \
          -w /helm-docs \
          jnorwood/helm-docs:latest \
          --document-dependency-values=true \
          --chart-search-root=charts/incubator

          # Check for uncommitted changes after helm-docs
          if ! git diff --exit-code; then
            echo "Documentation not up to date. Please run 'task update-readme' and commit changes!" >&2
            exit 1
          fi

  version-check:
    name: Chart Version Check
    needs: detect-changes
    runs-on: ubuntu-latest
    if: needs.detect-changes.outputs.changed == 'true'
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up chart-testing
        uses: helm/chart-testing-action@v2.1.0

      - name: Install yq
        run: |
          sudo wget -qO /usr/local/bin/yq https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64
          sudo chmod +x /usr/local/bin/yq

      - name: Check chart version increment
        run: |
          # Get the target branch from the PR
          target_branch="${{ github.event.pull_request.base.ref }}"
          echo "Target branch: $target_branch"

          changed_charts=$(ct list-changed --config "${CT_CONFIGFILE}")
          if [[ -z "$changed_charts" ]]; then
            echo "No changed charts to check."
            exit 0
          fi

          echo "::group::Checking chart versions"
          for chart in $changed_charts; do
            echo "Checking $chart..."
            chart_yaml="${chart}/Chart.yaml"

            # Check if chart exists in target branch
            if git show "origin/${target_branch}:${chart_yaml}" >/dev/null 2>&1; then
              old_version=$(git show "origin/${target_branch}:${chart_yaml}" | yq '.version')
              new_version=$(yq '.version' "${chart_yaml}")

              echo "  Old version: $old_version"
              echo "  New version: $new_version"

              # Version comparison using sort -V for semantic versioning
              if [[ "$old_version" == "$new_version" ]]; then
                echo "::error::$chart version was not incremented (still $new_version)"
                exit 1
              elif ! printf '%s\n%s\n' "$old_version" "$new_version" | sort -V -C; then
                echo "::error::$chart version $new_version is not greater than $old_version"
                exit 1
              else
                echo "::notice::✓ $chart version correctly incremented: $old_version → $new_version"
              fi
            else
              echo "::notice::$chart is new, skipping version check"
            fi
          done
          echo "::endgroup::"

  test-global-registry:
    name: Test Global Registry Override
    needs: detect-changes
    runs-on: ubuntu-latest
    if: needs.detect-changes.outputs.changed == 'true'
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Helm
        uses: azure/setup-helm@v4
        with:
          version: ${{ env.HELM_VERSION }}

      - name: Add Helm repositories
        run: |
          helm repo add bitnami https://charts.bitnami.com/bitnami
          helm repo add codecentric https://codecentric.github.io/helm-charts
          helm repo add vector https://helm.vector.dev
          helm repo add prometheus-community https://prometheus-community.github.io/helm-charts
          helm repo add grafana https://grafana.github.io/helm-charts
          helm repo add open-telemetry https://open-telemetry.github.io/opentelemetry-helm-charts
          helm repo update

      - name: Test Global Registry Coverage
        run: |
          # Known exceptions - third-party chart images that don't support global registry override
          declare -a EXCEPTIONS=(
            "docker.io/mailhog/mailhog:v1.0.1"
            "timberio/vector:0.42.0-distroless-libc"
          )

          TEST_REGISTRY="test-registry.example.com"
          CHART_NAME="test-release"

          echo "Testing global image registry override for hyperswitch-stack..."
          echo "Test registry: $TEST_REGISTRY"
          echo "Known exceptions: ${#EXCEPTIONS[@]} images"

          # Only test hyperswitch-stack chart
          cd charts/incubator/hyperswitch-stack

          # Update helm dependencies
          echo "Updating Helm dependencies..."
          if ! helm dependency update; then
            echo "FAILED: Helm dependency update failed"
            exit 1
          fi

          # Generate Helm template with global registry override
          echo "Generating Helm templates..."
          if ! helm template "$CHART_NAME" . --set global.imageRegistry="$TEST_REGISTRY" > /tmp/helm-output.yaml 2>/dev/null; then
            echo "FAILED: Helm template generation failed"
            exit 1
          fi

          # Extract all image references
          echo "Extracting image references..."
          grep -E '^\s*image:\s*' /tmp/helm-output.yaml | \
            sed -E 's/^\s*image:\s*"?([^"]*)"?.*/\1/' | \
            sort | uniq > /tmp/all-images.txt

          # Debug: Show all found images
          echo ""
          echo "DEBUG: All unique images found:"
          cat /tmp/all-images.txt | sed 's/^/   /'
          echo ""

          # Count total images
          TOTAL_IMAGES=$(wc -l < /tmp/all-images.txt)
          echo "Total unique images found: $TOTAL_IMAGES"

          # Find images NOT using the test registry
          grep -v "^$TEST_REGISTRY/" /tmp/all-images.txt > /tmp/non-global-images.txt || true

          # Debug: Show images not using global registry
          echo ""
          echo "DEBUG: Images NOT using test registry ($TEST_REGISTRY):"
          if [ -s /tmp/non-global-images.txt ]; then
            cat /tmp/non-global-images.txt | sed 's/^/   /'
          else
            echo "   (none)"
          fi
          echo ""

          # Filter out known exceptions
          cp /tmp/non-global-images.txt /tmp/unexpected-images.txt
          echo "DEBUG: Filtering out known exceptions..."
          for exception in "${EXCEPTIONS[@]}"; do
            echo "   Filtering out: $exception"
            before_count=$(wc -l < /tmp/unexpected-images.txt)
            grep -v "^$exception$" /tmp/unexpected-images.txt > /tmp/temp.txt || true
            mv /tmp/temp.txt /tmp/unexpected-images.txt
            after_count=$(wc -l < /tmp/unexpected-images.txt)
            removed_count=$((before_count - after_count))
            echo "     Removed $removed_count occurrences"
          done

          # Debug: Show final unexpected images
          echo ""
          echo "DEBUG: Final unexpected images (after filtering exceptions):"
          if [ -s /tmp/unexpected-images.txt ]; then
            cat /tmp/unexpected-images.txt | sed 's/^/   /'
          else
            echo "   (none)"
          fi
          echo ""

          # Count results
          GLOBAL_IMAGES=$(grep -c "^$TEST_REGISTRY/" /tmp/all-images.txt || echo "0")
          NON_GLOBAL_IMAGES=$(wc -l < /tmp/non-global-images.txt)
          UNEXPECTED_IMAGES=$(wc -l < /tmp/unexpected-images.txt)

          # Calculate coverage percentage
          COVERAGE=$((GLOBAL_IMAGES * 100 / TOTAL_IMAGES))

          echo ""
          echo "RESULTS:"
          echo "   Images using global registry: $GLOBAL_IMAGES"
          echo "   Images not using global registry: $NON_GLOBAL_IMAGES"
          echo "   Unexpected non-global images: $UNEXPECTED_IMAGES"
          echo "   Coverage: $COVERAGE%"

          # Debug: Show calculation details
          echo ""
          echo "DEBUG: Calculation details:"
          echo "   Total images: $TOTAL_IMAGES"
          echo "   Global registry images: $GLOBAL_IMAGES"
          echo "   Non-global images: $NON_GLOBAL_IMAGES"
          echo "   Unexpected images: $UNEXPECTED_IMAGES"
          echo "   Expected exceptions: ${#EXCEPTIONS[@]}"
          echo "   Math check: $GLOBAL_IMAGES + $NON_GLOBAL_IMAGES = $((GLOBAL_IMAGES + NON_GLOBAL_IMAGES)) (should equal $TOTAL_IMAGES)"
          echo ""

          # Show details of non-global images
          if [ $NON_GLOBAL_IMAGES -gt 0 ]; then
            echo ""
            echo "Images not using global registry:"
            while read -r image; do
              if printf '%s\n' "${EXCEPTIONS[@]}" | grep -q "^$image$"; then
                echo "   $image (known exception)"
              else
                echo "   $image (UNEXPECTED)"
              fi
            done < /tmp/non-global-images.txt
          fi

          # Test results
          echo ""
          echo "DEBUG: Test decision logic:"
          echo "   UNEXPECTED_IMAGES = $UNEXPECTED_IMAGES"
          echo "   Test condition: UNEXPECTED_IMAGES == 0"
          echo "   Will pass: $([ $UNEXPECTED_IMAGES -eq 0 ] && echo "YES" || echo "NO")"
          echo ""

          if [ $UNEXPECTED_IMAGES -eq 0 ]; then
            echo "PASSED: All images use global registry override (with expected exceptions)"
            echo "   Coverage: $COVERAGE% ($GLOBAL_IMAGES/$TOTAL_IMAGES images)"

            # Quality gates
            if [ $COVERAGE -lt 90 ]; then
              echo "WARNING: Coverage below 90% threshold"
            fi
          else
            echo "FAILED: $UNEXPECTED_IMAGES unexpected images not using global registry"
            echo ""
            echo "To fix:"
            echo "   1. Update image configurations to separate registry and repository"
            echo "   2. Ensure templates use: {{- \$registry := .Values.global.imageRegistry | default .Values.service.imageRegistry }}"
            echo "   3. If this is a known third-party limitation, add to exceptions list"
            echo ""
            echo "Unexpected images:"
            cat /tmp/unexpected-images.txt | sed 's/^/   /'

            exit 1
          fi
